#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
YouTrack Router Governance Bootstrap (FULL + Fields, robust CF attach)

- Crea il progetto (leader obbligatorio: usa --leader o l'utente del token)
- Crea/aggancia **Custom Fields globali** (schema-level) + **bundles enum**
- Aggancia i CF al progetto **usando gli ID** (fix per errore: "unable to locate CustomField unless ID provided")
- Inietta 120 issue (12 epiche, 36 task, 72 sub-task) con Due Date/SLA significativi

Esempi
  export YT_BASE_URL="https://<org>.youtrack.cloud"
  export YT_TOKEN="perm:..."
  python yt_governance_bootstrap.py --short ROUT --name "Router Governance" --prefix "[GOV] " --idempotent
  python yt_governance_bootstrap.py --short ROUT --name RouterNextGen --prefix "[GOV] " --leader you@org.com
"""

from __future__ import annotations
import argparse
import os
import sys
import time
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta, timezone

import requests

# ---------- Types & Defaults ----------
TYPE_EPIC = "Epic"
TYPE_TASK = "Task"
TYPE_SUBTASK = "Sub-task"

DEFAULT_DESCRIPTION = (
    "Auto-generated by yt_governance_bootstrap.py — Router Governance seed."
    "Adjust fields, links, and DoD as needed."
)

# Campi custom da creare/agganciare al progetto
ENUM_FIELDS = {
    "AutoFlag": ["None", "DelayRisk", "Overdue", "ScopeCreep", "QualityRisk"],
    "Owner Team": ["HW", "SW", "QA", "Ops", "Mktg", "Docs"],
    "Blocked": ["No", "Yes"],  # booleano come enum compatibile
}

TEXT_FIELDS = ["Blocked Reason"]
INT_FIELDS = ["Confidence"]
DATE_FIELDS = ["SLA Target"]

# ---------- HTTP Client ----------
class YTClient:
    def __init__(self, base_url: str, token: str, timeout: int = 25, max_retries: int = 3):
        self.base_url = base_url.rstrip("/")
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Bearer {token}",
            "Accept": "application/json",
            "Content-Type": "application/json",
        })
        adapter = requests.adapters.HTTPAdapter(max_retries=0)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        self.timeout = timeout
        self.max_retries = max_retries

    def _request(self, method: str, path: str, **kwargs):
        url = f"{self.base_url}{path}"
        last_exc = None
        for attempt in range(1, self.max_retries + 1):
            try:
                resp = self.session.request(method, url, timeout=self.timeout, **kwargs)
                if resp.status_code in (429, 500, 502, 503, 504):
                    wait = min(2 ** attempt, 10)
                    print(f"WARN {method} {path} -> {resp.status_code}, retrying in {wait}s", flush=True)
                    time.sleep(wait)
                    continue
                resp.raise_for_status()
                return resp
            except requests.RequestException as e:
                last_exc = e
                if attempt == self.max_retries:
                    raise
                wait = min(2 ** attempt, 10)
                print(f"WARN {method} {path} exception {e}, retry in {wait}s", flush=True)
                time.sleep(wait)
        if last_exc:
            raise last_exc

    def get(self, path: str, **kwargs):
        return self._request("GET", path, **kwargs)

    def post(self, path: str, **kwargs):
        return self._request("POST", path, **kwargs)

    def delete(self, path: str, **kwargs):
        return self._request("DELETE", path, **kwargs)

# ---------- Project & Field helpers ----------
class YTBootstrap:
    def __init__(self, yt: YTClient, dry_run: bool = False, idempotent: bool = False, prefix: str = ""):
        self.yt = yt
        self.dry_run = dry_run
        self.idempotent = idempotent
        self.prefix = prefix or ""

    # --- Projects ---
    def find_project_by_short_name(self, short_name: str) -> Optional[Dict]:
        fields = "id,shortName,name,description"
        resp = self.yt.get(f"/api/admin/projects?fields={fields}")
        for p in resp.json():
            if p.get("shortName") == short_name:
                return p
        return None

    def _resolve_leader_id(self, leader_login: Optional[str]) -> Dict:
        if leader_login:
            q = requests.utils.quote(leader_login)
            resp = self.yt.get(f"/api/users?query={q}&fields=id,login,name,email&$top=50")
            users = resp.json()
            for u in users:
                if u.get("login") == leader_login or u.get("email") == leader_login:
                    return {"id": u["id"]}
            if users:
                return {"id": users[0]["id"]}
            raise RuntimeError(f"Leader '{leader_login}' non trovato")
        else:
            me = self.yt.get("/api/users/me?fields=id,login,name").json()
            return {"id": me["id"]}

    def create_project(self, short_name: str, name: str, description: str = "", leader_login: Optional[str] = None) -> Dict:
        payload = {
            "name": name,
            "shortName": short_name,
            "description": description or "Created by yt_governance_bootstrap.py",
            "leader": self._resolve_leader_id(leader_login),
        }
        print(f"CREATE project {short_name} — {name}")
        if self.dry_run:
            return {"id": None, "shortName": short_name, "name": name}
        resp = self.yt.post("/api/admin/projects?fields=id,shortName,name,description", json=payload)
        return resp.json()

    # --- Enum bundles (value set) ---
    def _list_enum_bundles(self) -> List[Dict]:
        resp = self.yt.get("/api/admin/customFieldSettings/bundles/enum?fields=id,name,values(name)&$top=200")
        return resp.json()

    def ensure_enum_bundle(self, name: str, values: List[str]) -> Dict:
        bundles = self._list_enum_bundles()
        for b in bundles:
            if b.get("name") == name:
                have = {v.get("name") for v in (b.get("values", []) or [])}
                missing = [v for v in values if v not in have]
                if missing and not self.dry_run:
                    for v in missing:
                        try:
                            # YouTrack accetta la creazione singola: {"name": v}
                            print(f"ADD value to bundle {name}: '{v}'")
                            self.yt.post(
                                f"/api/admin/customFieldSettings/bundles/enum/{b['id']}/values?fields=id,name",
                                json={"name": v},
                            )
                        except requests.HTTPError:
                            # Fallback con $type esplicito (alcune istanze lo richiedono)
                            self.yt.post(
                                f"/api/admin/customFieldSettings/bundles/enum/{b['id']}/values?fields=id,name",
                                json={"name": v, "$type": "EnumBundleElement"},
                            )
                return b
        print(f"CREATE enum bundle: {name}")
        if self.dry_run:
            return {"id": f"DRY-B-{name}", "name": name}
        payload = {"name": name, "values": [{"name": v} for v in values]}
        resp = self.yt.post("/api/admin/customFieldSettings/bundles/enum?fields=id,name", json=payload)
        return resp.json()

# ---------- Global Custom Fields (schema) ----------
# YouTrack richiede l'ID del CustomField per l'associazione al progetto

def list_custom_fields(yt: YTClient) -> List[Dict]:
    return yt.get("/api/admin/customFieldSettings/customFields?fields=id,name,fieldType(id)").json()


def find_cf_by_name(yt: YTClient, name: str) -> Optional[Dict]:
    for cf in list_custom_fields(yt):
        if cf.get("name") == name:
            return cf
    return None


def create_cf(yt: YTClient, name: str, fieldtype_id: str, dry: bool) -> Dict:
    if dry:
        print(f"[DRY] Creerei CustomField {fieldtype_id} {name}")
        return {"id": f"DRY-CF-{name}", "name": name, "fieldType": {"id": fieldtype_id}}
    body = {"name": name, "fieldType": {"id": fieldtype_id}}
    return yt.post("/api/admin/customFieldSettings/customFields?fields=id,name,fieldType(id)", json=body).json()


def find_or_create_cf(yt: YTClient, name: str, fieldtype_id: str, dry: bool) -> Dict:
    cf = find_cf_by_name(yt, name)
    if cf:
        return cf
    return create_cf(yt, name, fieldtype_id, dry)


def get_cf_fieldtype_id(yt: YTClient, cf_id: str) -> str:
    data = yt.get(f"/api/admin/customFieldSettings/customFields/{cf_id}?fields=fieldType(id)").json()
    return (data.get("fieldType") or {}).get("id", "string")


def proj_cf_type_from_fieldtype(fieldtype_id: str) -> str:
    mapping = {
        "enum[1]": "EnumProjectCustomField",
        "enum[*]": "EnumProjectCustomField",
        "integer": "SimpleProjectCustomField",
        "date": "SimpleProjectCustomField",
        "string": "SimpleProjectCustomField",
        "text": "TextProjectCustomField",
    }
    return mapping.get(fieldtype_id, "SimpleProjectCustomField")


def list_project_cfs(yt: YTClient, project_id: str) -> List[Dict]:
    fields = "id,$type,field(id,name),customField(id,name),bundle(id,name,$type)"
    return yt.get(f"/api/admin/projects/{project_id}/customFields?fields={fields}").json()


def ensure_project_cf(yt: YTClient, project_id: str, cf_id: str, required: bool, dry: bool, bundle_id: Optional[str] = None) -> None:
    # esci se già presente
    for f in list_project_cfs(yt, project_id):
        linked = f.get("customField") or f.get("field") or {}
        if linked.get("id") == cf_id:
            return

    if dry:
        print(f"[DRY] Assocerei CF {cf_id} al progetto {project_id}" + (f" (bundle {bundle_id})" if bundle_id else ""))
        return

    ft_id = get_cf_fieldtype_id(yt, cf_id)
    proj_type = proj_cf_type_from_fieldtype(ft_id)

    base = {"$type": proj_type, "canBeEmpty": (not required)}
    if bundle_id:
        base["bundle"] = {"id": bundle_id, "$type": "EnumBundle"}

    # 1° tentativo: chiave 'customField'
    body = dict(base)
    body["customField"] = {"id": cf_id, "$type": "CustomField"}
    try:
        yt.post(f"/api/admin/projects/{project_id}/customFields?fields=id,$type,customField(id,name),bundle(id,name,$type)", json=body)
        return
    except requests.HTTPError:
        # 2° tentativo: chiave 'field' (alcune versioni la usano)
        body = dict(base)
        body["field"] = {"id": cf_id, "$type": "CustomField"}
        yt.post(f"/api/admin/projects/{project_id}/customFields?fields=id,$type,field(id,name),bundle(id,name,$type)", json=body)

# ---------- Issues API ----------
def get_project_type_bundle_id(yt: YTClient, project_id: str) -> Optional[str]:
    """Trova il bundle dell'Issue Type per il progetto (campo di sistema 'Type')."""
    fields = list_project_cfs(yt, project_id)
    for f in fields:
        field_name = (f.get("customField") or f.get("field") or {}).get("name")
        if field_name == "Type":
            b = f.get("bundle") or {}
            return b.get("id")
    return None


def list_enum_values(yt: YTClient, bundle_id: str) -> List[str]:
    data = yt.get(f"/api/admin/customFieldSettings/bundles/enum/{bundle_id}?fields=values(name)").json()
    return [v.get("name") for v in (data.get("values") or [])]


def ensure_enum_value(yt: YTClient, bundle_id: str, value_name: str, dry: bool = False) -> None:
    vals = set(list_enum_values(yt, bundle_id))
    if value_name in vals:
        return
    if dry:
        print(f"[DRY] Aggiungerei enum '{value_name}' al bundle {bundle_id}")
        return
    try:
        yt.post(f"/api/admin/customFieldSettings/bundles/enum/{bundle_id}/values?fields=id,name", json={"name": value_name})
    except requests.HTTPError:
        yt.post(f"/api/admin/customFieldSettings/bundles/enum/{bundle_id}/values?fields=id,name", json={"name": value_name, "$type": "EnumBundleElement"})


def resolve_issue_type_labels(yt: YTClient, project_id: str, dry: bool = False) -> Dict[str, str]:
    """Restituisce i nomi ESATTI da usare per Epic/Task/Sub-task nell'istanza corrente.
    Se 'Sub-task' non esiste ma esiste 'Subtask', userà quello. Se nessuno dei due esiste, lo crea.
    """
    bundle_id = get_project_type_bundle_id(yt, project_id)
    if not bundle_id:
        # fallback ai canonici
        return {"epic": "Epic", "task": "Task", "subtask": "Sub-task"}
    values = list_enum_values(yt, bundle_id)
    lower = {v.lower(): v for v in values}

    def pick(cands: List[str], default_new: Optional[str] = None) -> str:
        for c in cands:
            if c.lower() in lower:
                return lower[c.lower()]
        # non trovato
        if default_new:
            ensure_enum_value(yt, bundle_id, default_new, dry)
            return default_new
        # ultima spiaggia: primo del bundle
        return values[0] if values else cands[0]

    epic = pick(["Epic", "Epica"], None)
    task = pick(["Task", "Attività"], None)
    subtask = pick(["Sub-task", "Subtask", "Sub task", "Sotto-attività"], "Sub-task")
    return {"epic": epic, "task": task, "subtask": subtask}

# ---------- Issues API ----------
class IssueAPI:
    def __init__(self, yt: YTClient):
        self.yt = yt

    def search_issue_ids_in_project_by_summary(self, short_name: str, summary: str) -> List[Dict]:
        fields = "id,idReadable,summary,project(shortName)"
        q = requests.utils.quote(f"project: {short_name}")
        resp = self.yt.get(f"/api/issues?query={q}&fields={fields}&$top=200")
        return [i for i in resp.json() if i.get("summary") == summary]

    def create_issue(self, project_id: str, summary: str, description: str, issue_type: str,
                     parent_id: Optional[str], due_date_ms: Optional[int], sla_target_ms: Optional[int],
                     owner_team: Optional[str], autoflag: Optional[str], blocked: Optional[str], confidence: Optional[int]) -> Dict:
        custom_fields = [
            {"$type": "SingleEnumIssueCustomField", "name": "Type", "value": {"name": issue_type}},
        ]
        if owner_team:
            custom_fields.append({"$type": "SingleEnumIssueCustomField", "name": "Owner Team", "value": {"name": owner_team}})
        if autoflag:
            custom_fields.append({"$type": "SingleEnumIssueCustomField", "name": "AutoFlag", "value": {"name": autoflag}})
        if blocked:
            custom_fields.append({"$type": "SingleEnumIssueCustomField", "name": "Blocked", "value": {"name": blocked}})
        if confidence is not None:
            custom_fields.append({"$type": "SimpleIssueCustomField", "name": "Confidence", "value": confidence})
        if sla_target_ms is not None:
            custom_fields.append({"$type": "DateIssueCustomField", "name": "SLA Target", "value": sla_target_ms})

        payload: Dict = {
            "project": {"id": project_id},
            "summary": summary,
            "description": description,
            "customFields": custom_fields,
        }
        if parent_id:
            payload["parent"] = {"id": parent_id}
        if due_date_ms is not None:
            payload["dueDate"] = due_date_ms

        print(f"CREATE {issue_type}: {summary}" + (f" (parent={parent_id})" if parent_id else ""))
        resp = self.yt.post("/api/issues?fields=id,idReadable,summary,parent(id,idReadable)", json=payload)
        return resp.json()

# ---------- Seed & Scheduling ----------
IssueDef = Dict[str, Optional[str]]

EPIC_DUE = {
    "E-GOV": 90,
    "E-FS": 30,
    "E-HW": 75,
    "E-BL": 60,
    "E-BSP": 80,
    "E-NET": 90,
    "E-MGMT": 85,
    "E-SEC": 100,
    "E-QA": 110,
    "E-MFG": 130,
    "E-DOC": 120,
    "E-DEVOPS": 70,
}

TASK_DUE_DELTA = 20
SUB_DUE_DELTA = 7

DEFAULT_OWNER_BY_EPIC = {
    "E-GOV": "Ops",
    "E-FS": "Docs",
    "E-HW": "HW",
    "E-BL": "SW",
    "E-BSP": "SW",
    "E-NET": "SW",
    "E-MGMT": "SW",
    "E-SEC": "SW",
    "E-QA": "QA",
    "E-MFG": "Ops",
    "E-DOC": "Docs",
    "E-DEVOPS": "SW",
}

def _ms(dt_: datetime) -> int:
    return int(dt_.timestamp() * 1000)

def build_full_seed(prefix: str = "") -> List[IssueDef]:
    epics = [
        ("E-GOV",  "Product Governance & Requirements"),
        ("E-FS",   "Specifiche Funzionali"),
        ("E-HW",   "Hardware Platform"),
        ("E-BL",   "Bootloader"),
        ("E-BSP",  "OS/BSP & Kernel"),
        ("E-NET",  "Networking & Services"),
        ("E-MGMT", "Management & Telemetry"),
        ("E-SEC",  "Security & Compliance"),
        ("E-QA",   "Quality Assurance & Validation"),
        ("E-MFG",  "Manufacturing & Certification"),
        ("E-DOC",  "Documentazione & Training"),
        ("E-DEVOPS","DevOps & CI/CD"),
    ]

    tasks_by_epic: Dict[str, List[Tuple[str, str]]] = {
        "E-GOV": [("T-GOV-1", "Visione prodotto, stakeholder, scope"), ("T-GOV-2", "OKR, KPI e metriche di successo"), ("T-GOV-3", "Analisi competitor, pricing e roadmap")],
        "E-FS": [("T-FS-1", "Raccolta requisiti funzionali e non funzionali"), ("T-FS-2", "Casi d'uso, scenari e vincoli"), ("T-FS-3", "Revisione e sign-off FS v1.0")],
        "E-HW": [("T-HW-1", "Scelta SoC, memoria, PHY, radio, power-tree"), ("T-HW-2", "Schematic, layout PCB e regole HS"), ("T-HW-3", "Prototipazione, BOM freeze e bring-up")],
        "E-BL": [("T-BL-1", "Porting U-Boot, device-tree e env"), ("T-BL-2", "Secure boot, chiavi e anti-rollback"), ("T-BL-3", "Fastboot/recovery e flashing pipeline")],
        "E-BSP": [("T-BSP-1", "Config kernel e driver (NIC/PHY/modem)"), ("T-BSP-2", "Build system (Yocto/Debian) e immagini"), ("T-BSP-3", "OTA updater, partizionamento A/B e fallback")],
        "E-NET": [("T-NET-1", "Routing/NAT/FW IPv4/IPv6 e conntrack"), ("T-NET-2", "VPN (IPsec/OpenVPN/WireGuard) e AAA"), ("T-NET-3", "L2/L3 switching, VLAN/EVPN/QoS")],
        "E-MGMT": [("T-MGMT-1", "WebUI/CLI con RBAC e audit"), ("T-MGMT-2", "API REST/DBus, OpenAPI e SDK"), ("T-MGMT-3", "Telemetry NetFlow/IPFIX, Prometheus")],
        "E-SEC": [("T-SEC-1", "Threat modeling e mitigazione"), ("T-SEC-2", "Hardening OS, SSH policy, MAC"), ("T-SEC-3", "SBOM (CycloneDX), SCA e vuln mgmt")],
        "E-QA": [("T-QA-1", "Test plan: unit/integration/regression"), ("T-QA-2", "Test automatici CI/HIL"), ("T-QA-3", "Field trials, KPI e quality report")],
        "E-MFG": [("T-MFG-1", "Pre-compliance EMC/EMI"), ("T-MFG-2", "Certificazioni CE/FCC e doc"), ("T-MFG-3", "Collaudi EOL e procedure fabbrica")],
        "E-DOC": [("T-DOC-1", "Manuale utente e guida admin"), ("T-DOC-2", "Developer guide e API docs"), ("T-DOC-3", "Training interno e webinar")],
        "E-DEVOPS": [("T-DEVOPS-1", "Repo layout, coding style e hooks"), ("T-DEVOPS-2", "CI/CD pipeline build/test/release"), ("T-DEVOPS-3", "Artifact registry e SBOM gates")],
    }

    subtasks_by_task: Dict[str, List[str]] = {
        "T-GOV-1": ["Stakeholder interviews", "Scope statement e boundaries"],
        "T-GOV-2": ["Definizione OKR trimestrali", "Dashboard KPI iniziale"],
        "T-GOV-3": ["Mappatura competitor", "Pricing preliminare"],
        "T-FS-1": ["Template requisiti", "Backlog requisiti"],
        "T-FS-2": ["Scenari prioritari", "Vincoli prestazionali"],
        "T-FS-3": ["Review con stakeholder", "Sign-off FS"],
        "T-HW-1": ["Trade-off SoC", "BoM iniziale"],
        "T-HW-2": ["Regole di layout", "Review schematico"],
        "T-HW-3": ["Bring-up checklist", "Test di alimentazione"],
        "T-BL-1": ["DT compatibilità", "Env U-Boot"],
        "T-BL-2": ["Key provisioning", "Anti-rollback test"],
        "T-BL-3": ["Script flashing", "Recovery validation"],
        "T-BSP-1": ["Driver NIC/PHY", "Modem QMI/MBIM"],
        "T-BSP-2": ["Yocto layer", "Debian rootfs"],
        "T-BSP-3": ["A/B slots", "Rollback strategy"],
        "T-NET-1": ["NAT/conntrack tuning", "Firewall policy base"],
        "T-NET-2": ["IPsec profiles", "OpenVPN/WG config"],
        "T-NET-3": ["VLAN/EVPN test", "QoS/TC shaping"],
        "T-MGMT-1": ["RBAC roles", "Audit log"],
        "T-MGMT-2": ["OpenAPI spec", "SDK Python"],
        "T-MGMT-3": ["Exporter Prometheus", "Dashboard Grafana"],
        "T-SEC-1": ["STRIDE session", "Threat mitigation"],
        "T-SEC-2": ["SSH hardening", "MAC policy"],
        "T-SEC-3": ["CycloneDX gen", "SCA pipeline"],
        "T-QA-1": ["Matrix test", "Acceptance criteria"],
        "T-QA-2": ["HIL scripts", "CI regression"],
        "T-QA-3": ["Trial plan", "KPI report"],
        "T-MFG-1": ["Pre-scan EMC", "Fix emissioni"],
        "T-MFG-2": ["Doc CE/FCC", "Test conformità"],
        "T-MFG-3": ["Procedure EOL", "Jig di test"],
        "T-DOC-1": ["Manuale bozza", "Guida admin bozza"],
        "T-DOC-2": ["Dev guide", "API reference"],
        "T-DOC-3": ["Slide training", "Calendario webinar"],
        "T-DEVOPS-1": ["Repo template", "Pre-commit hooks"],
        "T-DEVOPS-2": ["CI pipeline", "Release pipeline"],
        "T-DEVOPS-3": ["Artifact registry", "SBOM policy"],
    }

    seed: List[IssueDef] = []

    # Epics
    for e_alias, e_title in epics:
        seed.append({
            "alias": e_alias,
            "type": TYPE_EPIC,
            "summary": f"{prefix}{e_title}",
            "description": DEFAULT_DESCRIPTION,
            "parent_alias": None,
            "owner_team": DEFAULT_OWNER_BY_EPIC[e_alias],
            "due_in_days": EPIC_DUE[e_alias],
        })

    # Tasks
    for e_alias, _ in epics:
        for t_alias, t_title in tasks_by_epic[e_alias]:
            seed.append({
                "alias": t_alias,
                "type": TYPE_TASK,
                "summary": f"{prefix}{t_title}",
                "description": DEFAULT_DESCRIPTION,
                "parent_alias": e_alias,
                "owner_team": DEFAULT_OWNER_BY_EPIC[e_alias],
                "due_in_days": EPIC_DUE[e_alias] - TASK_DUE_DELTA,
            })

    # Subtasks
    for e_alias, _ in epics:
        for t_alias, _ in tasks_by_epic[e_alias]:
            for idx, st_title in enumerate(subtasks_by_task[t_alias], start=1):
                s_alias = f"S-{t_alias}-{idx}"
                seed.append({
                    "alias": s_alias,
                    "type": TYPE_SUBTASK,
                    "summary": f"{prefix}{st_title}",
                    "description": DEFAULT_DESCRIPTION,
                    "parent_alias": t_alias,
                    "owner_team": DEFAULT_OWNER_BY_EPIC[e_alias],
                    "due_in_days": EPIC_DUE[e_alias] - TASK_DUE_DELTA - SUB_DUE_DELTA,
                    "sla_in_days": 7,
                })

    return seed

# ---------- Orchestrator ----------

def run(
    seed: List[IssueDef],
    base_url: str,
    token: str,
    short_name: str,
    name: str,
    description: str,
    dry_run: bool,
    idempotent: bool,
    prefix: str,
    leader_login: Optional[str],
) -> None:
    yt = YTClient(base_url, token)
    boot = YTBootstrap(yt, dry_run=dry_run, idempotent=idempotent, prefix=prefix)
    issue_api = IssueAPI(yt)

    proj = boot.find_project_by_short_name(short_name)

    if proj is None:
        if dry_run:
            print(f"DRY-RUN: creerei il progetto {short_name} — {name} (leader={leader_login or 'me'}). Salto operazioni di campo/issue perché l'ID non esiste ancora.")
            project_id = None
        else:
            proj = boot.create_project(short_name, name, description, leader_login=leader_login)
            print(f"INFO Project created: {proj.get('id')} {proj.get('name')}")
            project_id = proj["id"]
    else:
        print(f"INFO Project exists: {proj.get('id')} {proj.get('name')}")
        project_id = proj["id"]

    # Se siamo in dry-run e il progetto non esiste ancora: stampa solo il piano e termina
    if project_id is None:
        epics = [i for i in seed if i["type"] == TYPE_EPIC]
        tasks = [i for i in seed if i["type"] == TYPE_TASK]
        subs  = [i for i in seed if i["type"] == TYPE_SUBTASK]
        print(f"PLAN Epics={len(epics)} Tasks={len(tasks)} Sub-tasks={len(subs)} (totale={len(seed)})")
        print("PLAN Campi progetto da creare/agganciare:")
        for fname, vals in ENUM_FIELDS.items():
            print(f"  - Enum {fname}: {vals}")
        for f in TEXT_FIELDS:
            print(f"  - Text {f}")
        for f in INT_FIELDS:
            print(f"  - Integer {f}")
        for f in DATE_FIELDS:
            print(f"  - Date {f}")
        return

    # ---------- Ensure bundles & custom fields (schema) ----------
    # 1) Bundles enum
    bundle_ids: Dict[str, str] = {}
    for field, values in ENUM_FIELDS.items():
        b = boot.ensure_enum_bundle(field, values)
        bundle_ids[field] = b.get("id")

    # 2) Custom fields globali (schema-level)
    cf_map: Dict[str, Dict] = {}
    # enum
    cf_map["AutoFlag"]  = find_or_create_cf(yt, "AutoFlag", "enum[1]", dry_run)
    cf_map["Owner Team"] = find_or_create_cf(yt, "Owner Team", "enum[1]", dry_run)
    cf_map["Blocked"]   = find_or_create_cf(yt, "Blocked", "enum[1]", dry_run)
    # text/string/integer/date
    cf_map["Blocked Reason"] = find_or_create_cf(yt, "Blocked Reason", "text", dry_run)
    cf_map["Confidence"]     = find_or_create_cf(yt, "Confidence", "integer", dry_run)
    cf_map["SLA Target"]     = find_or_create_cf(yt, "SLA Target", "date", dry_run)

    # 3) Attach CF al progetto via ID (+ bundle per enum)
    ensure_project_cf(yt, project_id, cf_map["AutoFlag"]["id"], required=False, dry=dry_run, bundle_id=bundle_ids.get("AutoFlag"))
    ensure_project_cf(yt, project_id, cf_map["Owner Team"]["id"], required=False, dry=dry_run, bundle_id=bundle_ids.get("Owner Team"))
    ensure_project_cf(yt, project_id, cf_map["Blocked"]["id"], required=False, dry=dry_run, bundle_id=bundle_ids.get("Blocked"))

    ensure_project_cf(yt, project_id, cf_map["Blocked Reason"]["id"], required=False, dry=dry_run)
    ensure_project_cf(yt, project_id, cf_map["Confidence"]["id"], required=False, dry=dry_run)
    ensure_project_cf(yt, project_id, cf_map["SLA Target"]["id"], required=False, dry=dry_run)

    # 4) Risolvi i nomi reali delle Issue Types (Epic/Task/Sub-task) per la tua istanza
    type_names = resolve_issue_type_labels(yt, project_id, dry_run)

# ---------- Create issues ----------
    alias_to_issue: Dict[str, Dict] = {}

    def maybe_existing(summary: str) -> Optional[Dict]:
        if not idempotent:
            return None
        candidates = issue_api.search_issue_ids_in_project_by_summary(short_name, summary)
        return candidates[0] if candidates else None

    tz = timezone.utc
    today = datetime.now(tz).replace(hour=9, minute=0, second=0, microsecond=0)

    epics = [i for i in seed if i["type"] == TYPE_EPIC]
    tasks = [i for i in seed if i["type"] == TYPE_TASK]
    subs  = [i for i in seed if i["type"] == TYPE_SUBTASK]

    # Epics
    for item in epics:
        summary = item["summary"]
        existing = maybe_existing(summary)
        if existing:
            print(f"IDEMPOTENT Found Epic: {existing.get('idReadable')} {summary}")
            alias_to_issue[item["alias"]] = existing
            continue
        due = today + timedelta(days=int(item.get("due_in_days", 90)))
        created = issue_api.create_issue(
            project_id=project_id,
            summary=summary,
            description=item["description"],
            issue_type=type_names["epic"],
            parent_id=None,
            due_date_ms=_ms(due),
            sla_target_ms=None,
            owner_team=item.get("owner_team"),
            autoflag="None",
            blocked="No",
            confidence=70,
        )
        alias_to_issue[item["alias"]] = created

    # Tasks
    for item in tasks:
        parent_alias = item.get("parent_alias")
        parent_id = alias_to_issue.get(parent_alias, {}).get("id") if parent_alias else None
        summary = item["summary"]
        existing = maybe_existing(summary)
        if existing:
            print(f"IDEMPOTENT Found Task: {existing.get('idReadable')} {summary}")
            alias_to_issue[item["alias"]] = existing
            continue
        due = today + timedelta(days=int(item.get("due_in_days", 60)))
        created = issue_api.create_issue(
            project_id=project_id,
            summary=summary,
            description=item["description"],
            issue_type=type_names["task"],
            parent_id=parent_id,
            due_date_ms=_ms(due),
            sla_target_ms=None,
            owner_team=item.get("owner_team"),
            autoflag="None",
            blocked="No",
            confidence=75,
        )
        alias_to_issue[item["alias"]] = created

    # Subtasks
    for item in subs:
        parent_alias = item.get("parent_alias")
        parent_id = alias_to_issue.get(parent_alias, {}).get("id") if parent_alias else None
        summary = item["summary"]
        existing = maybe_existing(summary)
        if existing:
            print(f"IDEMPOTENT Found Sub-task: {existing.get('idReadable')} {summary}")
            alias_to_issue[item["alias"]] = existing
            continue
        due = today + timedelta(days=int(item.get("due_in_days", 45)))
        sla = today + timedelta(days=int(item.get("sla_in_days", 7))) if item.get("sla_in_days") else None
        created = issue_api.create_issue(
            project_id=project_id,
            summary=summary,
            description=item["description"],
            issue_type=type_names["subtask"],
            parent_id=parent_id,
            due_date_ms=_ms(due),
            sla_target_ms=_ms(sla) if sla else None,
            owner_team=item.get("owner_team"),
            autoflag="None",
            blocked="No",
            confidence=80,
        )
        alias_to_issue[item["alias"]] = created

    print(f"INFO Completed. Issues processed: {len(alias_to_issue)}")

# ---------- CLI ----------

def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
    p = argparse.ArgumentParser(description="YouTrack Router Governance Bootstrap (FULL + Fields)")
    p.add_argument("--base", dest="base_url", default=os.environ.get("YT_BASE_URL", ""), help="YouTrack base URL (or env YT_BASE_URL)")
    p.add_argument("--token", dest="token", default=os.environ.get("YT_TOKEN", ""), help="YouTrack permanent token (or env YT_TOKEN)")
    p.add_argument("--short", dest="short_name", default="ROUT", help="Project key (shortName), default ROUT")
    p.add_argument("--name", dest="name", default="Router Governance", help="Project name")
    p.add_argument("--desc", dest="description", default="Programma di Governance per router L3/L2.", help="Project description")
    p.add_argument("--leader", dest="leader_login", default=os.environ.get("YT_LEADER", None), help="Login/email dell'utente leader del progetto (se omesso usa l'utente del token)")
    p.add_argument("--prefix", dest="prefix", default="[GOV] ", help="Prefix for all summaries (e.g., [GOV] )")
    p.add_argument("--dry-run", dest="dry_run", action="store_true", help="Do not perform mutations; stampa solo il piano se il progetto non esiste")
    p.add_argument("--idempotent", dest="idempotent", action="store_true", help="Skip creation if issue with same summary exists in project")
    return p.parse_args(argv)


def main(argv: Optional[List[str]] = None) -> int:
    args = parse_args(argv)
    if not args.base_url or not args.token:
        print("ERROR --base or --token missing (or env YT_BASE_URL / YT_TOKEN)")
        return 2

    seed = build_full_seed(prefix=args.prefix)
    try:
        run(
            seed=seed,
            base_url=args.base_url,
            token=args.token,
            short_name=args.short_name,
            name=args.name,
            description=args.description,
            dry_run=args.dry_run,
            idempotent=args.idempotent,
            prefix=args.prefix,
            leader_login=args.leader_login,
        )
    except requests.HTTPError as e:
        print(f"ERROR HTTP {e.response.status_code if e.response else ''}: {getattr(e.response, 'text', e)}")
        return 1
    except Exception as e:
        print(f"ERROR {e}")
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
